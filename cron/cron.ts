// ============================================================================
// TUKTUK CRON JOB SETUP SCRIPT
// ============================================================================
//
// This script creates a RECURRING cron job using Helium's cron-sdk.
// Unlike the on-chain `schedule` instruction (which queues ONE task),
// this creates a repeating schedule that runs automatically.
//
// ARCHITECTURE:
//
//   ┌──────────────────┐
//   │   This Script    │  Runs ONCE to set up the cron job
//   │   (cron.ts)      │
//   └────────┬─────────┘
//            │ Creates cron job + attaches compiled instruction
//            ▼
//   ┌──────────────────┐
//   │  TukTuk Cron     │  On-chain cron job account
//   │  Job Account     │  Stores: schedule, compiled tx, funding
//   └────────┬─────────┘
//            │ Every 60 seconds (based on schedule)
//            ▼
//   ┌──────────────────┐
//   │  TukTuk Task     │  Cranker picks up the queued task
//   │  Queue           │
//   └────────┬─────────┘
//            │ Cranker executes compiled transaction
//            ▼
//   ┌──────────────────┐
//   │  Our Program     │  `scheduled_update` is called
//   │  (er-state-acct) │  user_account.data += 1
//   └──────────────────┘
//
// HOW TO RUN:
//   anchor run cron
//   or:
//   yarn run ts-node cron/cron.ts \
//     --cronName er-state-cron \
//     --queueName er-state-queue \
//     --walletPath ~/.config/solana/id.json \
//     --rpcUrl https://api.devnet.solana.com
//
// HOW TO STOP:
//   tuktuk -u <rpcUrl> -w <walletPath> cron-transaction close --cron-name <name> --id 0
//   tuktuk -u <rpcUrl> -w <walletPath> cron close --cron-name <name>
// ============================================================================

import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import {
  createCronJob,
  cronJobTransactionKey,
  getCronJobForName,
  init as initCron,
} from "@helium/cron-sdk";
import {
  compileTransaction,
  init,
  taskQueueAuthorityKey,
} from "@helium/tuktuk-sdk";
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  TransactionInstruction,
} from "@solana/web3.js";
import yargs from "yargs";
import { hideBin } from "yargs/helpers";
import { sendInstructions } from "@helium/spl-utils";
import { ErStateAccount } from "../target/types/er_state_account";

// ============================================================================
// PROGRAM SETUP
// ============================================================================
// Load our program from the Anchor workspace.
// anchor.workspace reads from target/idl/*.json which is generated by
// `anchor build`. The IDL contains all instruction definitions, account
// structs, and type info needed to interact with the program.
const erProgram = anchor.workspace
  .erStateAccount as Program<ErStateAccount>;

// Derive the user account PDA that our cron job will modify.
// Seeds: ["user", wallet_pubkey] - same derivation as in the Rust program.
// The cron job's compiled instruction will target this specific account.
const getUserAccount = (walletPubkey: anchor.web3.PublicKey) =>
  anchor.web3.PublicKey.findProgramAddressSync(
    [Buffer.from("user"), walletPubkey.toBuffer()],
    erProgram.programId,
  )[0];

async function main() {
  // ==========================================================================
  // PARSE CLI ARGUMENTS
  // ==========================================================================
  const argv = await yargs(hideBin(process.argv))
    .options({
      cronName: {
        type: "string",
        description: "Name for the cron job (must be unique per wallet)",
        demandOption: true,
      },
      queueName: {
        type: "string",
        description: "Name of the TukTuk task queue to use",
        demandOption: true,
      },
      walletPath: {
        type: "string",
        description: "Path to your Solana wallet keypair JSON file",
        demandOption: true,
      },
      rpcUrl: {
        type: "string",
        description: "Solana RPC endpoint URL",
        demandOption: true,
      },
      // How much SOL to fund the cron job with.
      // This SOL pays for crank rewards over time.
      // When it runs out, the cron job stops executing.
      fundingAmount: {
        type: "number",
        description: "SOL to fund the cron job with (in lamports)",
        default: 0.01 * LAMPORTS_PER_SOL,
      },
    })
    .help()
    .alias("help", "h").argv;

  // ==========================================================================
  // INITIALIZE PROVIDERS AND PROGRAMS
  // ==========================================================================
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);
  const wallet = provider.wallet as anchor.Wallet;

  console.log("Using wallet:", wallet.publicKey.toBase58());
  console.log("RPC URL:", argv.rpcUrl);

  // Initialize the TukTuk SDK - this loads the TukTuk program interface
  // TukTuk Program ID: tuktukUrfhXT6ZT77QTU8RQtvgL967uRuVagWF57zVA
  const tuktukProgram = await init(provider);

  // Initialize the Cron SDK - this loads the cron management program
  // The cron program sits on top of TukTuk, adding schedule-based triggers
  const cronProgram = await initCron(provider);

  // The task queue where our cron tasks will be submitted.
  // This queue must already exist - create it with TukTuk CLI:
  //   tuktuk queue create --name <queueName>
  // TODO: Replace with your actual task queue address
  const taskQueue = new anchor.web3.PublicKey(
    "CMreFdKxT5oeZhiX8nWTGz9PtXM1AMYTh6dGR2UzdtrA",
  );

  // Derive the user account PDA for our wallet
  const userAccount = getUserAccount(wallet.publicKey);
  console.log("User Account PDA:", userAccount.toBase58());

  // ==========================================================================
  // STEP 1: Ensure our wallet is a queue authority
  // ==========================================================================
  // Before submitting tasks, our wallet must be registered as an authority
  // on the task queue. This is a one-time setup per wallet per queue.
  const taskQueueAuthorityPda = taskQueueAuthorityKey(
    taskQueue,
    wallet.publicKey,
  )[0];
  const taskQueueAuthorityInfo =
    await provider.connection.getAccountInfo(taskQueueAuthorityPda);

  if (!taskQueueAuthorityInfo) {
    console.log("Registering wallet as task queue authority...");
    await tuktukProgram.methods
      .addQueueAuthorityV0()
      .accounts({
        payer: wallet.publicKey,
        queueAuthority: wallet.publicKey,
        taskQueue,
      })
      .rpc({ skipPreflight: true });
    console.log("Task queue authority registered!");
  } else {
    console.log("Task queue authority already registered");
  }

  // ==========================================================================
  // STEP 2: Create the cron job (or skip if it already exists)
  // ==========================================================================
  let cronJob = await getCronJobForName(cronProgram, argv.cronName);

  if (!cronJob) {
    console.log("Creating new cron job...");

    // createCronJob: Creates an on-chain cron job account that will
    // automatically queue tasks on the TukTuk task queue at the
    // specified schedule interval.
    const {
      pubkeys: { cronJob: cronJobPubkey },
    } = await (
      await createCronJob(cronProgram, {
        tuktukProgram: tuktukProgram,
        taskQueue,
        args: {
          // Human-readable name (must be unique per wallet)
          name: argv.cronName,

          // CRON SCHEDULE FORMAT (6 fields):
          //   Second Minute Hour DayOfMonth Month DayOfWeek
          //
          // Examples:
          //   "0 * * * * *"     = every minute (at second 0)
          //   "*/30 * * * * *"  = every 30 seconds
          //   "0 0 * * * *"    = every hour
          //   "0 0 0 * * *"    = every day at midnight
          //
          // We use every minute for demonstration purposes
          schedule: "0 * * * * *",

          // How many "free" tasks per cron trigger (no crank fee deducted).
          // Our scheduled_update doesn't need to schedule more tasks,
          // so 0 free tasks is fine.
          freeTasksPerTransaction: 0,

          // How many tasks to queue per cron trigger.
          // We only need one task per trigger: the scheduled_update call.
          numTasksPerQueueCall: 1,
        },
      })
    ).rpcAndKeys({ skipPreflight: false });

    cronJob = cronJobPubkey;
    console.log("Cron job created:", cronJob.toBase58());

    // ========================================================================
    // STEP 3: Fund the cron job with SOL for crank rewards
    // ========================================================================
    // The cron job account holds lamports that pay crankers for each execution.
    // When the balance runs out, crankers stop executing the tasks.
    // You can top up the cron job anytime by sending more SOL to it.
    console.log(
      "Funding cron job with",
      argv.fundingAmount / LAMPORTS_PER_SOL,
      "SOL",
    );
    await sendInstructions(provider, [
      SystemProgram.transfer({
        fromPubkey: provider.publicKey,
        toPubkey: cronJob,
        lamports: argv.fundingAmount,
      }),
    ]);

    // ========================================================================
    // STEP 4: Compile and attach our instruction to the cron job
    // ========================================================================
    // We build the `scheduled_update` instruction manually, compile it into
    // TukTuk's format, and attach it to the cron job.
    //
    // Each cron trigger will execute this exact instruction.

    // Build the Solana instruction for scheduled_update
    // This is equivalent to calling: program.methods.scheduledUpdate().accounts({...})
    // but constructed manually so we can compile it for TukTuk
    const scheduledUpdateIx = new TransactionInstruction({
      keys: [
        // The only account needed: the user_account PDA (mutable, not signer)
        { pubkey: userAccount, isSigner: false, isWritable: true },
      ],
      // Encode the instruction discriminator for "scheduled_update"
      // The coder reads the IDL to produce the correct 8-byte discriminator
      data: erProgram.coder.instruction.encode("scheduled_update", {}),
      programId: erProgram.programId,
    });

    // Compile the instruction into TukTuk's compressed transaction format
    console.log("Compiling scheduled_update instruction...");
    const { transaction, remainingAccounts } = compileTransaction(
      [scheduledUpdateIx],
      [], // No additional signers
    );

    // Attach the compiled transaction to the cron job at index 0.
    // A cron job can have multiple transactions (index 0, 1, 2...),
    // but we only need one: the scheduled_update call.
    await cronProgram.methods
      .addCronTransactionV0({
        index: 0, // First (and only) transaction in this cron job
        transactionSource: {
          compiledV0: [transaction], // TukTuk's compiled format
        },
      })
      .accounts({
        payer: provider.publicKey,
        cronJob,
        // Derived PDA for cron job transaction storage
        cronJobTransaction: cronJobTransactionKey(cronJob, 0)[0],
      })
      .remainingAccounts(remainingAccounts)
      .rpc({ skipPreflight: true });

    console.log("Cron job configured with scheduled_update instruction!");
  } else {
    console.log("Cron job already exists:", cronJob.toBase58());
  }

  // ==========================================================================
  // DONE! Print summary and cleanup instructions
  // ==========================================================================
  console.log("\n=== CRON JOB ACTIVE ===");
  console.log("Cron job address:", cronJob.toBase58());
  console.log("User account:", userAccount.toBase58());
  console.log(
    `\nThe scheduled_update instruction will run every minute.`,
  );
  console.log(
    `Watch for transactions on task queue: ${taskQueue.toBase58()}`,
  );
  console.log(`\nTo stop the cron job:`);
  console.log(
    `  tuktuk -u ${argv.rpcUrl} -w ${argv.walletPath} cron-transaction close --cron-name ${argv.cronName} --id 0`,
  );
  console.log(
    `  tuktuk -u ${argv.rpcUrl} -w ${argv.walletPath} cron close --cron-name ${argv.cronName}`,
  );
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
