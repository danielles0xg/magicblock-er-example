// queues a scheduled_update task on tuktuk via CPI
// user signs + pays, cranker picks it up later and runs it
//
// we use declare_program! instead of tuktuk-program crate bc anchor version conflict
// (they use 0.31.1, we need 0.32.1) -- generates CPI types from idls/tuktuk.json

use std::collections::HashMap;
use anchor_lang::{prelude::*, InstructionData};
use anchor_lang::solana_program::instruction::Instruction;

use crate::state::UserAccount;

// reads idls/tuktuk.json and generates all the CPI types we need
declare_program!(tuktuk);

use tuktuk::{
    cpi::{
        accounts::QueueTaskV0,
        queue_task_v0,
    },
    program::Tuktuk,
    types::{
        TriggerV0,
        TransactionSourceV0,
        QueueTaskArgsV0,
        CompiledTransactionV0,
        CompiledInstructionV0,
    },
};

#[derive(Accounts)]
pub struct Schedule<'info> {
    // pays for the task creation + crank reward
    #[account(mut)]
    pub user: Signer<'info>,

    #[account(
        mut,
        seeds = [b"user", user.key().as_ref()],
        bump = user_account.bump,
    )]
    pub user_account: Account<'info, UserAccount>,

    // tuktuk accounts -- all unchecked bc tuktuk validates them in the CPI
    /// CHECK: tuktuk validates
    #[account(mut)]
    pub task_queue: UncheckedAccount<'info>,

    /// CHECK: tuktuk validates
    pub task_queue_authority: UncheckedAccount<'info>,

    /// CHECK: tuktuk inits this
    #[account(mut)]
    pub task: UncheckedAccount<'info>,

    // our programs identity PDA for tuktuk -- signs the CPI
    // must be registered on the queue first (see cron.ts or tuktuk cli)
    /// CHECK: our PDA
    #[account(
        mut,
        seeds = [b"queue_authority"],
        bump
    )]
    pub queue_authority: AccountInfo<'info>,

    pub system_program: Program<'info, System>,
    pub tuktuk_program: Program<'info, Tuktuk>,
}

impl<'info> Schedule<'info> {
    pub fn schedule(&mut self, task_id: u16, bumps: ScheduleBumps) -> Result<()> {
        // build the ix we want the cranker to run (scheduled_update)
        // __cpi_client_accounts_* is auto-generated by anchor derive
        let (compiled_tx, _) = compile_transaction(
            vec![Instruction {
                program_id: crate::ID,
                accounts: crate::__cpi_client_accounts_scheduled_update::ScheduledUpdate {
                    user_account: self.user_account.to_account_info(),
                }
                .to_account_metas(None)
                .to_vec(),
                data: crate::instruction::ScheduledUpdate {}.data(),
            }],
            vec![],
        )
        .unwrap();

        // CPI to tuktuk -- queue_authority PDA signs so tuktuk knows its us
        queue_task_v0(
            CpiContext::new_with_signer(
                self.tuktuk_program.to_account_info(),
                QueueTaskV0 {
                    payer: self.user.to_account_info(),
                    queue_authority: self.queue_authority.to_account_info(),
                    task_queue: self.task_queue.to_account_info(),
                    task_queue_authority: self.task_queue_authority.to_account_info(),
                    task: self.task.to_account_info(),
                    system_program: self.system_program.to_account_info(),
                },
                &[&[b"queue_authority", &[bumps.queue_authority]]],
            ),
            QueueTaskArgsV0 {
                trigger: TriggerV0::Now, // run asap, for cron see cron/cron.ts
                transaction: TransactionSourceV0::CompiledV0(compiled_tx),
                crank_reward: Some(1000001), // ~0.001 SOL for the cranker
                free_tasks: 1,
                id: task_id, // must be unique per queue, u16
                description: "Scheduled update: increment user data".to_string(),
            },
        )?;

        msg!("Task {} queued on TukTuk for scheduled update!", task_id);
        Ok(())
    }
}

// converts normal solana ixs into tuktuk's compact format
// dedupes accounts, sorts by priority, uses indices instead of full pubkeys
// adapted from tuktuk-program crate (cant use it directly bc anchor version)
pub fn compile_transaction(
    instructions: Vec<Instruction>,
    signer_seeds: Vec<Vec<Vec<u8>>>,
) -> Result<(CompiledTransactionV0, Vec<AccountMeta>)> {
    let mut pubkeys_to_metadata: HashMap<Pubkey, AccountMeta> = HashMap::new();

    for ix in &instructions {
        pubkeys_to_metadata
            .entry(ix.program_id)
            .or_insert(AccountMeta {
                pubkey: ix.program_id,
                is_signer: false,
                is_writable: false,
            });

        for key in &ix.accounts {
            let entry = pubkeys_to_metadata
                .entry(key.pubkey)
                .or_insert(AccountMeta {
                    is_signer: false,
                    is_writable: false,
                    pubkey: key.pubkey,
                });
            entry.is_writable |= key.is_writable;
            entry.is_signer |= key.is_signer;
        }
    }

    let mut sorted_accounts: Vec<Pubkey> = pubkeys_to_metadata.keys().cloned().collect();
    sorted_accounts.sort_by(|a, b| {
        let a_meta = &pubkeys_to_metadata[a];
        let b_meta = &pubkeys_to_metadata[b];

        fn get_priority(meta: &AccountMeta) -> u8 {
            match (meta.is_signer, meta.is_writable) {
                (true, true) => 0,
                (true, false) => 1,
                (false, true) => 2,
                (false, false) => 3,
            }
        }

        get_priority(a_meta).cmp(&get_priority(b_meta))
    });

    let mut num_rw_signers = 0u8;
    let mut num_ro_signers = 0u8;
    let mut num_rw = 0u8;

    for k in &sorted_accounts {
        let metadata = &pubkeys_to_metadata[k];
        if metadata.is_signer && metadata.is_writable {
            num_rw_signers += 1;
        } else if metadata.is_signer && !metadata.is_writable {
            num_ro_signers += 1;
        } else if metadata.is_writable {
            num_rw += 1;
        }
    }

    let accounts_to_index: HashMap<Pubkey, u8> = sorted_accounts
        .iter()
        .enumerate()
        .map(|(i, k)| (*k, i as u8))
        .collect();

    let compiled_instructions: Vec<CompiledInstructionV0> = instructions
        .iter()
        .map(|ix| CompiledInstructionV0 {
            program_id_index: *accounts_to_index.get(&ix.program_id).unwrap(),
            accounts: ix
                .accounts
                .iter()
                .map(|k| *accounts_to_index.get(&k.pubkey).unwrap())
                .collect(),
            data: ix.data.clone(),
        })
        .collect();

    let remaining_accounts = sorted_accounts
        .iter()
        .enumerate()
        .map(|(index, k)| AccountMeta {
            pubkey: *k,
            is_signer: false,
            is_writable: index < num_rw_signers as usize
                || (index >= num_rw_signers as usize + num_ro_signers as usize
                    && index
                        < num_rw_signers as usize + num_ro_signers as usize + num_rw as usize),
        })
        .collect();

    Ok((
        CompiledTransactionV0 {
            num_ro_signers,
            num_rw_signers,
            num_rw,
            instructions: compiled_instructions,
            signer_seeds,
            accounts: sorted_accounts,
        },
        remaining_accounts,
    ))
}
